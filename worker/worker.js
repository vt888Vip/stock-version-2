#!/usr/bin/env node

import amqp from 'amqplib';
import mongoose from 'mongoose';

// Configuration
const RABBITMQ_URL = process.env.RABBITMQ_URL || 'amqps://seecjpys:zQCC056kIx1vnMmrImQqAAVbVUUfmk0M@fuji.lmq.cloudamqp.com/seecjpys';
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://stock-version-2:Vincent79@stockdb.ssitqfx.mongodb.net/finacial_platfom';
const SETTLEMENTS_QUEUE = 'settlements';

let connection;
let channel;
let db;

// Mongoose Models
const TradingSessionSchema = new mongoose.Schema({
  sessionId: { type: String, required: true, unique: true },
  startTime: { type: Date, required: true },
  endTime: { type: Date, required: true },
  status: { type: String, enum: ['ACTIVE', 'COMPLETED'], default: 'ACTIVE' },
  result: { type: String, enum: ['UP', 'DOWN'] },
  actualResult: { type: String, enum: ['UP', 'DOWN'] },
  processingComplete: { type: Boolean, default: false },
  processingStarted: { type: Boolean, default: false },
  processingStartedAt: { type: Date },
  createdBy: { type: String },
  totalTrades: { type: Number, default: 0 },
  totalWins: { type: Number, default: 0 },
  totalLosses: { type: Number, default: 0 },
  totalWinAmount: { type: Number, default: 0 },
  totalLossAmount: { type: Number, default: 0 },
  completedAt: { type: Date }
}, { timestamps: true });

const TradeSchema = new mongoose.Schema({
  sessionId: { type: String, required: true },
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  direction: { type: String, enum: ['UP', 'DOWN'], required: true },
  amount: { type: Number, required: true },
  status: { type: String, enum: ['pending', 'completed'], default: 'pending' },
  result: { type: String, enum: ['win', 'lose'] },
  profit: { type: Number },
  appliedToBalance: { type: Boolean, default: false }
}, { timestamps: true });

const UserSchema = new mongoose.Schema({
  balance: {
    available: { type: Number, default: 0 },
    frozen: { type: Number, default: 0 }
  }
}, { timestamps: true });

const TradingSession = mongoose.model('TradingSession', TradingSessionSchema, 'trading_sessions');
const Trade = mongoose.model('Trade', TradeSchema, 'trades');
const User = mongoose.model('User', UserSchema, 'users');

/**
 * K·∫øt n·ªëi MongoDB v·ªõi Mongoose
 */
async function connectMongoDB() {
  try {
    console.log('üîå K·∫øt n·ªëi MongoDB v·ªõi Mongoose...');
    
    if (mongoose.connection.readyState === 1) {
      console.log('‚úÖ MongoDB ƒë√£ ƒë∆∞·ª£c k·∫øt n·ªëi');
      return mongoose.connection;
    }
    
    await mongoose.connect(MONGODB_URI, {
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
    });
    
    console.log('‚úÖ MongoDB connected v·ªõi Mongoose');
    return mongoose.connection;
  } catch (error) {
    console.error('‚ùå L·ªói k·∫øt n·ªëi MongoDB:', error);
    throw error;
  }
}

/**
 * X√≥a v√† t·∫°o l·∫°i queues
 */
async function resetQueues() {
  try {
    console.log('üßπ ƒêang x√≥a queues c≈©...');
    await channel.deleteQueue(SETTLEMENTS_QUEUE);
    console.log('‚úÖ ƒê√£ x√≥a settlements queue c≈©');
  } catch (error) {
    console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a settlements queue (c√≥ th·ªÉ ch∆∞a t·ªìn t·∫°i):', error.message);
  }
}

/**
 * K·∫øt n·ªëi RabbitMQ
 */
async function connectRabbitMQ() {
  try {
    console.log('üîå K·∫øt n·ªëi RabbitMQ...');
    connection = await amqp.connect(RABBITMQ_URL);
    
    connection.on('error', (error) => {
      console.error('‚ùå RabbitMQ connection error:', error);
    });

    connection.on('close', () => {
      console.log('üîå RabbitMQ connection closed');
    });

    channel = await connection.createChannel();
    
    // X√≥a v√† t·∫°o l·∫°i queues ƒë·ªÉ tr√°nh xung ƒë·ªôt
    await resetQueues();
    
    // Ch·ªâ t·∫°o queue settlements - orders ƒë∆∞·ª£c x·ª≠ l√Ω tr·ª±c ti·∫øp b·ªüi API
    await channel.assertQueue(SETTLEMENTS_QUEUE, {
      durable: true,
      maxPriority: 10
    });

    console.log('‚úÖ RabbitMQ connected v√† queues ƒë√£ ƒë∆∞·ª£c t·∫°o');
    return { connection, channel };
  } catch (error) {
    console.error('‚ùå L·ªói k·∫øt n·ªëi RabbitMQ:', error);
    throw error;
  }
}

// ƒê√£ b·ªè h√†m processOrder - kh√¥ng c·∫ßn worker cho orders n·ªØa

/**
 * X·ª≠ l√Ω settlement (k·∫øt qu·∫£)
 */
async function processSettlement(settlementData) {
  const session = await mongoose.startSession();
  
  try {
    console.log(`üîÑ [SETTLEMENT] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω settlement: ${settlementData.id}`);
    
    const result = await session.withTransaction(async () => {
      const { sessionId } = settlementData;

      // 1. L·∫•y k·∫øt qu·∫£ c√≥ s·∫µn t·ª´ session
      const sessionDoc = await mongoose.connection.db.collection('trading_sessions').findOne(
        { sessionId },
        { result: 1 }
      );
      
      if (!sessionDoc || !sessionDoc.result) {
        throw new Error('Session not found or no result available');
      }
      
      const sessionResult = sessionDoc.result;
      console.log(`üìä [SETTLEMENT] S·ª≠ d·ª•ng k·∫øt qu·∫£ c√≥ s·∫µn: ${sessionResult} cho session ${sessionId}`);

      // 2. C·∫≠p nh·∫≠t session status
      const sessionUpdateResult = await mongoose.connection.db.collection('trading_sessions').updateOne(
        { sessionId },
        {
          $set: {
            status: 'COMPLETED',
            actualResult: sessionResult,
            processingComplete: true,
            updatedAt: new Date()
          }
        }
      );

      if (sessionUpdateResult.modifiedCount === 0) {
        throw new Error('Session not found or already completed');
      }

      // 2. L·∫•y t·∫•t c·∫£ trades pending trong session (s·ª≠ d·ª•ng c√πng collection v·ªõi API)
      const pendingTrades = await mongoose.connection.db.collection('trades').find({ 
        sessionId, 
        status: 'pending' 
      }).toArray();

      console.log(`üìä [SETTLEMENT] T√¨m th·∫•y ${pendingTrades.length} trades c·∫ßn x·ª≠ l√Ω`);

      let totalWins = 0;
      let totalLosses = 0;
      let totalWinAmount = 0;
      let totalLossAmount = 0;

             // 3. X·ª≠ l√Ω t·ª´ng trade
       for (const trade of pendingTrades) {
         const isWin = trade.direction === sessionResult;
         // ‚úÖ T·ª∂ L·ªÜ 10 ƒÇN 9: ƒê·∫∑t 10 th·∫Øng 9, ƒë·∫∑t 100 th·∫Øng 90
         const profit = isWin ? Math.floor(trade.amount * 0.9) : 0;

        // C·∫≠p nh·∫≠t trade (s·ª≠ d·ª•ng c√πng collection v·ªõi API)
        await mongoose.connection.db.collection('trades').updateOne(
          { _id: trade._id },
          {
            $set: {
              status: 'completed',
              result: isWin ? 'win' : 'lose',
              profit: profit,
              appliedToBalance: true,
              updatedAt: new Date()
            }
          }
        );

                 // ‚úÖ ƒê√öNG: C·∫≠p nh·∫≠t balance khi x·ª≠ l√Ω settlement
         if (isWin) {
           // TH·∫ÆNG: Tr·∫£ l·∫°i ti·ªÅn g·ªëc + ti·ªÅn th·∫Øng
           await mongoose.connection.db.collection('users').updateOne(
             { _id: trade.userId },
             {
               $inc: {
                 'balance.frozen': -trade.amount,
                 'balance.available': trade.amount + profit
               },
               $set: {
                 updatedAt: new Date()
               }
             }
           );
         } else {
           // THUA: Ch·ªâ tr·ª´ frozen (m·∫•t ti·ªÅn)
           await mongoose.connection.db.collection('users').updateOne(
             { _id: trade.userId },
             {
               $inc: {
                 'balance.frozen': -trade.amount
               },
               $set: {
                 updatedAt: new Date()
               }
             }
           );
         }

        // C·∫≠p nh·∫≠t th·ªëng k√™
        if (isWin) {
          totalWins++;
          totalWinAmount += trade.amount;
        } else {
          totalLosses++;
          totalLossAmount += trade.amount;
        }

        console.log(`‚úÖ [SETTLEMENT] X·ª≠ l√Ω trade ${trade._id}: ${isWin ? 'WIN' : 'LOSE'} ${trade.amount}`);
      }

      // 4. C·∫≠p nh·∫≠t session statistics v√† ƒë√°nh d·∫•u ho√†n th√†nh (s·ª≠ d·ª•ng c√πng collection v·ªõi API)
      await mongoose.connection.db.collection('trading_sessions').updateOne(
        { sessionId },
        {
          $set: {
            totalTrades: pendingTrades.length,
            totalWins: totalWins,
            totalLosses: totalLosses,
            totalWinAmount: totalWinAmount,
            totalLossAmount: totalLossAmount,
            processingComplete: true,
            processingCompletedAt: new Date(),
            updatedAt: new Date()
          }
        }
      );

      console.log(`‚úÖ [SETTLEMENT] X·ª≠ l√Ω settlement th√†nh c√¥ng: ${settlementData.id}`);
      console.log(`üìä [SETTLEMENT] Th·ªëng k√™: ${pendingTrades.length} trades, ${totalWins} wins, ${totalLosses} losses`);
      
      return {
        success: true,
        sessionId,
        result: sessionResult,
        totalTrades: pendingTrades.length,
        totalWins,
        totalLosses,
        totalWinAmount,
        totalLossAmount
      };
    });

    return result;
  } catch (error) {
    console.error(`‚ùå [SETTLEMENT] L·ªói x·ª≠ l√Ω settlement ${settlementData.id}:`, error.message);
    return {
      success: false,
      error: error.message
    };
  } finally {
    await session.endSession();
  }
}

/**
 * Kh·ªüi ƒë·ªông worker
 */
async function startWorker() {
  try {
    console.log('üöÄ Kh·ªüi ƒë·ªông Trade Worker...');
    
    // K·∫øt n·ªëi databases
    await connectMongoDB();
    await connectRabbitMQ();
    
    // Thi·∫øt l·∫≠p prefetch
    await channel.prefetch(1);
    
    console.log('‚úÖ Worker ƒë√£ s·∫µn s√†ng x·ª≠ l√Ω messages');
    
        // ƒê√£ b·ªè consumer cho orders - kh√¥ng c·∫ßn worker cho orders n·ªØa
    console.log('üìã Ch·ªâ x·ª≠ l√Ω settlements - orders ƒë∆∞·ª£c x·ª≠ l√Ω tr·ª±c ti·∫øp b·ªüi API');
    
    // Consumer cho settlements
    channel.consume(SETTLEMENTS_QUEUE, async (msg) => {
      if (!msg) return;
      
      try {
        const settlementData = JSON.parse(msg.content.toString());
        console.log(`üì• [SETTLEMENTS] Nh·∫≠n settlement message:`, {
          id: settlementData.id,
          sessionId: settlementData.sessionId,
          result: settlementData.result,
          timestamp: settlementData.timestamp
        });
        
        console.log(`üîÑ [SETTLEMENTS] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω settlement: ${settlementData.sessionId}`);
        
        const result = await processSettlement(settlementData);
        
        if (result.success) {
          console.log(`‚úÖ [SETTLEMENTS] X·ª≠ l√Ω settlement th√†nh c√¥ng:`, {
            sessionId: result.sessionId,
            result: result.result,
            totalTrades: result.totalTrades,
            totalWins: result.totalWins,
            totalLosses: result.totalLosses
          });
        } else {
          console.error(`‚ùå [SETTLEMENTS] X·ª≠ l√Ω settlement th·∫•t b·∫°i: ${settlementData.id} - ${result.error}`);
        }
        
        channel.ack(msg);
        console.log(`‚úÖ [SETTLEMENTS] ƒê√£ acknowledge message: ${settlementData.id}`);
      } catch (error) {
        console.error(`‚ùå [SETTLEMENTS] L·ªói x·ª≠ l√Ω message:`, error);
        channel.ack(msg); // Acknowledge ƒë·ªÉ tr√°nh loop
      }
    });
    
    console.log('üéâ Worker ƒë√£ kh·ªüi ƒë·ªông th√†nh c√¥ng!');
    console.log('üìã ƒêang l·∫Øng nghe:');
    console.log(`   - Settlements queue: ${SETTLEMENTS_QUEUE} (ch·ªâ x·ª≠ l√Ω settlements)`);
    console.log(`   - Orders ƒë∆∞·ª£c x·ª≠ l√Ω tr·ª±c ti·∫øp b·ªüi API`);
    
  } catch (error) {
    console.error('‚ùå L·ªói kh·ªüi ƒë·ªông worker:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nüõë ƒêang t·∫Øt worker...');
  
  if (channel) {
    await channel.close();
  }
  
  if (connection) {
    await connection.close();
  }
  
  console.log('‚úÖ Worker ƒë√£ t·∫Øt');
  process.exit(0);
});

// Start worker
startWorker();
