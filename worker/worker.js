#!/usr/bin/env node
import path from 'path';
import fs from 'fs';
import dotenv from 'dotenv';

import amqp from 'amqplib';
import mongoose from 'mongoose';
import fetch from 'node-fetch';
import { createClient } from 'redis';

// Load environment from .env.local for standalone Node worker
(() => {
  const envPath = path.resolve(process.cwd(), '.env.local');
  if (fs.existsSync(envPath)) {
    dotenv.config({ path: envPath });
    console.log(`üì¶ Loaded environment from .env.local`);
  }
})();

// Configuration - RabbitMQ Local Open Source
const RABBITMQ_URL = process.env.RABBITMQ_URL || 'amqp://trading_user:trading_password@localhost:5672';
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://vincent:vincent79@cluster0.btgvgm.mongodb.net/finacial_platform';
const REDIS_URL = process.env.REDIS_URL || 'redis://localhost:6379';
const REDIS_HOST = process.env.REDIS_HOST || 'localhost';
const REDIS_PORT = parseInt(process.env.REDIS_PORT || '6379');
const REDIS_DB = parseInt(process.env.REDIS_DB || '0');
const REDIS_PASSWORD = process.env.REDIS_PASSWORD || undefined;
const SETTLEMENTS_QUEUE = 'settlements';
const TRADE_PROCESSING_QUEUE = 'trade-processing';
const SOCKET_SERVER_URL = process.env.SOCKET_SERVER_URL || (process.env.NODE_ENV === 'production' 
  ? 'http://127.0.0.1:3001' 
  : 'http://localhost:3001');

let connection;
let channel;
let db;
let redisClient;

// Mongoose Models
const TradingSessionSchema = new mongoose.Schema({
  sessionId: { type: String, required: true, unique: true },
  startTime: { type: Date, required: true },
  endTime: { type: Date, required: true },
  status: { type: String, enum: ['ACTIVE', 'COMPLETED'], default: 'ACTIVE' },
  result: { type: String, enum: ['UP', 'DOWN'] },
  actualResult: { type: String, enum: ['UP', 'DOWN'] },
  processingComplete: { type: Boolean, default: false },
  processingStarted: { type: Boolean, default: false },
  processingStartedAt: { type: Date },
  createdBy: { type: String },
  totalTrades: { type: Number, default: 0 },
  totalWins: { type: Number, default: 0 },
  totalLosses: { type: Number, default: 0 },
  totalWinAmount: { type: Number, default: 0 },
  totalLossAmount: { type: Number, default: 0 },
  completedAt: { type: Date }
}, { timestamps: true });

const TradeSchema = new mongoose.Schema({
  sessionId: { type: String, required: true },
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  direction: { type: String, enum: ['UP', 'DOWN'], required: true },
  amount: { type: Number, required: true },
  status: { type: String, enum: ['pending', 'completed'], default: 'pending' },
  result: { type: String, enum: ['win', 'lose'] },
  profit: { type: Number },
  appliedToBalance: { type: Boolean, default: false }
}, { timestamps: true });

const UserSchema = new mongoose.Schema({
  balance: {
    available: { type: Number, default: 0 },
    frozen: { type: Number, default: 0 }
  }
}, { timestamps: true });

const TradingSession = mongoose.model('TradingSession', TradingSessionSchema, 'trading_sessions');
const Trade = mongoose.model('Trade', TradeSchema, 'trades');
const User = mongoose.model('User', UserSchema, 'users');

/**
 * K·∫øt n·ªëi Redis
 */
async function connectRedis() {
  try {
    console.log('üîå K·∫øt n·ªëi Redis...');
    console.log('üîß Redis config:', {
      url: REDIS_URL,
      host: REDIS_HOST,
      port: REDIS_PORT,
      db: REDIS_DB,
      password: REDIS_PASSWORD ? '*** set ***' : '(none)'
    });
    
    redisClient = createClient({
      url: REDIS_URL,
      socket: {
        host: REDIS_HOST,
        port: REDIS_PORT,
        reconnectStrategy: (retries) => {
          const delay = Math.min(1000 * Math.pow(2, retries), 15000);
          return delay;
        },
        connectTimeout: 10000,
        keepAlive: 1,
      },
      password: REDIS_PASSWORD,
      database: REDIS_DB,
    });

    redisClient.on('error', (err) => {
      console.error('‚ùå Redis Client Error:', err);
    });

    redisClient.on('connect', () => {
      console.log('‚úÖ Redis connected');
    });

    redisClient.on('disconnect', () => {
      console.log('üîå Redis disconnected');
    });
    redisClient.on('reconnecting', () => {
      console.log('‚è≥ Redis reconnecting...');
    });

    await redisClient.connect();
    console.log('‚úÖ Redis connection established');
    return redisClient;
  } catch (error) {
    console.error('‚ùå L·ªói k·∫øt n·ªëi Redis:', error);
    throw error;
  }
}

/**
 * K·∫øt n·ªëi MongoDB v·ªõi Mongoose
 */
async function connectMongoDB() {
  try {
    console.log('üîå K·∫øt n·ªëi MongoDB v·ªõi Mongoose...');
    
    if (mongoose.connection.readyState === 1) {
      console.log('‚úÖ MongoDB ƒë√£ ƒë∆∞·ª£c k·∫øt n·ªëi');
      return mongoose.connection;
    }
    
    await mongoose.connect(MONGODB_URI, {
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
    });
    
    console.log('‚úÖ MongoDB connected v·ªõi Mongoose');

    // Ensure indexes for idempotency and uniqueness (run once if missing)
    try {
      await mongoose.connection.db.collection('trades').createIndex({ tradeId: 1 }, { unique: true, name: 'uniq_tradeId' });
      await mongoose.connection.db.collection('trading_sessions').createIndex({ sessionId: 1 }, { unique: true, name: 'uniq_sessionId' });
      console.log('‚úÖ Ensured unique indexes for trades.tradeId and trading_sessions.sessionId');
    } catch (idxErr) {
      console.warn('‚ö†Ô∏è Index ensure warning:', idxErr?.message || idxErr);
    }
    return mongoose.connection;
  } catch (error) {
    console.error('‚ùå L·ªói k·∫øt n·ªëi MongoDB:', error);
    throw error;
  }
}

/**
 * X√≥a v√† t·∫°o l·∫°i queues
 */
async function resetQueues() {
  try {
    console.log('üßπ ƒêang x√≥a queues c≈©...');
    await channel.deleteQueue(SETTLEMENTS_QUEUE);
    await channel.deleteQueue(TRADE_PROCESSING_QUEUE);
    console.log('‚úÖ ƒê√£ x√≥a queues c≈©');
  } catch (error) {
    console.log('‚ö†Ô∏è Kh√¥ng th·ªÉ x√≥a queues (c√≥ th·ªÉ ch∆∞a t·ªìn t·∫°i):', error.message);
  }
}

/**
 * K·∫øt n·ªëi RabbitMQ
 */
async function connectRabbitMQ() {
  try {
    console.log('üîå K·∫øt n·ªëi RabbitMQ...');
    connection = await amqp.connect(RABBITMQ_URL);
    
    connection.on('error', (error) => {
      console.error('‚ùå RabbitMQ connection error:', error);
    });

    connection.on('close', () => {
      console.log('üîå RabbitMQ connection closed');
    });

    channel = await connection.createChannel();
    
    // X√≥a v√† t·∫°o l·∫°i queues ƒë·ªÉ tr√°nh xung ƒë·ªôt
    await resetQueues();
    
    // T·∫°o queue settlements
    await channel.assertQueue(SETTLEMENTS_QUEUE, {
      durable: true,
      maxPriority: 10
    });

    // T·∫°o queue trade-processing
    await channel.assertQueue(TRADE_PROCESSING_QUEUE, {
      durable: true,
      maxPriority: 10
    });

    console.log('‚úÖ RabbitMQ connected v√† queues ƒë√£ ƒë∆∞·ª£c t·∫°o');
    return { connection, channel };
  } catch (error) {
    console.error('‚ùå L·ªói k·∫øt n·ªëi RabbitMQ:', error);
    throw error;
  }
}

/**
 * Redis Lock utilities
 */
const lockOwners = new Map();

async function acquireLock(key, ttl = 30000) {
  try {
    const lockKey = `lock:${key}`;
    const lockValue = `${Date.now()}-${Math.random()}`;
    console.log(`üîê [LOCK] Trying acquire: key=${lockKey} ttl=${ttl}ms`);
    const result = await redisClient.set(lockKey, lockValue, {
      PX: ttl,
      NX: true
    });
    const acquired = result === 'OK';
    if (acquired) {
      console.log(`‚úÖ [LOCK] Acquired: key=${lockKey}`);
      lockOwners.set(lockKey, lockValue);
    } else {
      console.log(`‚õî [LOCK] Busy (not acquired): key=${lockKey}`);
    }
    return acquired;
  } catch (error) {
    console.error(`‚ùå Failed to acquire lock ${key}:`, error);
    return false;
  }
}

async function releaseLock(key) {
  try {
    const lockKey = `lock:${key}`;
    console.log(`üîì [LOCK] Releasing: key=${lockKey}`);
    const owner = lockOwners.get(lockKey);
    const script = `
      if redis.call('GET', KEYS[1]) == ARGV[1] then
        return redis.call('DEL', KEYS[1])
      else
        return 0
      end
    `;
    const result = await redisClient.eval(script, { keys: [lockKey], arguments: [owner || ''] });
    const released = Number(result) > 0;
    if (released) {
      console.log(`‚úÖ [LOCK] Released: key=${lockKey}`);
      lockOwners.delete(lockKey);
    } else {
      console.log(`‚ö†Ô∏è [LOCK] Not held (nothing to release): key=${lockKey}`);
    }
    return released;
  } catch (error) {
    console.error(`‚ùå Failed to release lock ${key}:`, error);
    return false;
  }
}

/**
 * Redis Cache utilities
 */
async function getBalanceFromCache(userId) {
  try {
    const balanceKey = `user:${userId}:balance`;
    const balance = await redisClient.hGetAll(balanceKey);
    
    if (Object.keys(balance).length === 0) {
      return null;
    }
    
    return {
      available: parseInt(balance.available || '0'),
      frozen: parseInt(balance.frozen || '0')
    };
  } catch (error) {
    console.error(`‚ùå Failed to get balance from cache for user ${userId}:`, error);
    return null;
  }
}

async function setBalanceToCache(userId, balance) {
  try {
    const balanceKey = `user:${userId}:balance`;
    
    await redisClient.hSet(balanceKey, {
      available: balance.available.toString(),
      frozen: balance.frozen.toString(),
      updatedAt: new Date().toISOString()
    });
    
    // Set TTL to 1 hour
    await redisClient.expire(balanceKey, 3600);
  } catch (error) {
    console.error(`‚ùå Failed to set balance to cache for user ${userId}:`, error);
  }
}

async function updateBalanceInCache(userId, changes) {
  try {
    const balanceKey = `user:${userId}:balance`;
    
    const multi = redisClient.multi();
    
    if (changes.available !== undefined) {
      multi.hIncrBy(balanceKey, 'available', changes.available);
    }
    
    if (changes.frozen !== undefined) {
      multi.hIncrBy(balanceKey, 'frozen', changes.frozen);
    }
    
    multi.hSet(balanceKey, 'updatedAt', new Date().toISOString());
    multi.expire(balanceKey, 3600);
    
    await multi.exec();
  } catch (error) {
    console.error(`‚ùå Failed to update balance in cache for user ${userId}:`, error);
  }
}

async function isTradeProcessed(tradeId) {
  try {
    const tradeKey = `trade:${tradeId}:processed`;
    const exists = await redisClient.exists(tradeKey);
    return exists === 1;
  } catch (error) {
    console.error(`‚ùå Failed to check trade status ${tradeId}:`, error);
    return false;
  }
}

async function markTradeProcessed(tradeId, ttl = 3600) {
  try {
    const tradeKey = `trade:${tradeId}:processed`;
    await redisClient.set(tradeKey, 'true', { EX: ttl });
  } catch (error) {
    console.error(`‚ùå Failed to mark trade processed ${tradeId}:`, error);
  }
}

async function getSessionResultFromCache(sessionId) {
  try {
    const sessionKey = `session:${sessionId}:result`;
    return await redisClient.get(sessionKey);
  } catch (error) {
    console.error(`‚ùå Failed to get session result from cache ${sessionId}:`, error);
    return null;
  }
}

async function setSessionResultToCache(sessionId, result, ttl = 7200) {
  try {
    const sessionKey = `session:${sessionId}:result`;
    await redisClient.set(sessionKey, result, { EX: ttl });
  } catch (error) {
    console.error(`‚ùå Failed to set session result to cache ${sessionId}:`, error);
  }
}

/**
 * X·ª≠ l√Ω place trade tr·ª±c ti·∫øp v·ªõi Redis lock
 */
async function processPlaceTradeDirect(tradeId, userId, sessionId, amount, type) {
  const session = await mongoose.startSession();
  
  try {
    return await session.withTransaction(async () => {
      // 1. Ki·ªÉm tra trade ƒë√£ t·ªìn t·∫°i ch∆∞a
      const existingTrade = await mongoose.connection.db.collection('trades').findOne({ tradeId });
      if (existingTrade) {
        throw new Error(`Trade already exists: ${tradeId}`);
      }

      // 2. Ki·ªÉm tra user balance v√† status
      const userResult = await mongoose.connection.db.collection('users').findOneAndUpdate(
        {
          _id: new mongoose.Types.ObjectId(userId),
          'balance.available': { $gte: amount },
          'status.active': true,
          'status.betLocked': { $ne: true }
        },
        {
          $inc: {
            'balance.available': -amount,
            'balance.frozen': amount
          },
          $set: {
            updatedAt: new Date()
          }
        },
        { 
          session, 
          returnDocument: 'after'
        }
      );
      
      if (!userResult) {
        throw new Error('Insufficient balance or user locked');
      }

      // 3. T·∫°o trade record
      const trade = {
        tradeId,
        userId: new mongoose.Types.ObjectId(userId),
        sessionId,
        amount,
        type,
        status: 'pending',
        createdAt: new Date(),
        retryCount: 0,
        direction: type === 'buy' ? 'UP' : 'DOWN',
        appliedToBalance: false
      };

      await mongoose.connection.db.collection('trades').insertOne(trade, { session });

      return {
        success: true,
        tradeId,
        balance: {
          available: userResult.balance.available,
          frozen: userResult.balance.frozen
        }
      };
    });
  } catch (error) {
    console.error(`‚ùå [PLACE-TRADE-DIRECT] L·ªói x·ª≠ l√Ω ƒë·∫∑t l·ªánh ${tradeId}:`, error.message);
    return {
      success: false,
      error: error.message
    };
  } finally {
    await session.endSession();
  }
}

/**
 * X·ª≠ l√Ω place trade (ƒë·∫∑t l·ªánh) v·ªõi Redis atomic operations
 */
async function processPlaceTrade(tradeData) {
  const { tradeId, userId, sessionId, amount, type } = tradeData;
  try {
    console.log(`üìù [PLACE-TRADE] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω ƒë·∫∑t l·ªánh: ${tradeData.tradeId}`);

    const lockKey = `user:${userId}:balance`;
    const lockAcquired = await acquireLock(lockKey, 30000);
    if (!lockAcquired) {
      console.log(`‚ùå [PLACE-TRADE] Kh√¥ng th·ªÉ acquire lock cho user ${userId}`);
      return { success: false, error: 'User is being processed by another request' };
    }

    let result;
    try {
      result = await processPlaceTradeDirect(tradeId, userId, sessionId, amount, type);
    } finally {
      await releaseLock(lockKey);
    }

    if (result && result.success) {
      await sendSocketEvent(userId, 'trade:placed', {
        tradeId: result.tradeId,
        sessionId,
        direction: type === 'buy' ? 'UP' : 'DOWN',
        amount,
        type,
        status: 'pending',
        message: 'L·ªánh ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh c√¥ng'
      });

      // ‚úÖ TH√äM: G·ª≠i balance:updated event khi ƒë·∫∑t l·ªánh
      await sendSocketEvent(userId, 'balance:updated', {
        userId,
        tradeId: result.tradeId,
        balance: result.balance,
        amount: -amount, // S·ªë ti·ªÅn b·ªã tr·ª´
        message: `ƒê√£ ƒë·∫∑t l·ªánh ${amount.toLocaleString()} VND`
      });

      // ‚úÖ TH√äM: G·ª≠i balance:updated event ch·ªâ ƒë·∫øn admin
      await sendSocketEvent('admin', 'balance:updated', {
        userId,
        tradeId: result.tradeId,
        balance: result.balance,
        amount: -amount, // S·ªë ti·ªÅn b·ªã tr·ª´
        message: `User ${userId} ƒë√£ ƒë·∫∑t l·ªánh ${amount.toLocaleString()} VND`
      });

      await sendSocketEvent(userId, 'trade:history:updated', {
        action: 'add',
        trade: {
          id: result.tradeId,
          tradeId: result.tradeId,
          sessionId,
          direction: type === 'buy' ? 'UP' : 'DOWN',
          amount,
          type,
          status: 'pending',
          result: null,
          profit: 0,
          createdAt: new Date().toISOString()
        },
        message: 'L·ªãch s·ª≠ giao d·ªãch ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t'
      });

      console.log(`‚úÖ [PLACE-TRADE] ƒê·∫∑t l·ªánh th√†nh c√¥ng: ${result.tradeId}`);
    } else if (result) {
      console.log(`‚ùå [PLACE-TRADE] ƒê·∫∑t l·ªánh th·∫•t b·∫°i: ${result.error}`);
    }

    return result;
  } catch (error) {
    console.error(`‚ùå [PLACE-TRADE] L·ªói x·ª≠ l√Ω ƒë·∫∑t l·ªánh ${tradeData.tradeId}:`, error.message);
    return { success: false, error: error.message };
  }
}

/**
 * X·ª≠ l√Ω check result tr·ª±c ti·∫øp (kh√¥ng qua queue) cho m·ªôt trade
 */
async function processCheckResultDirect(tradeId, userId, sessionId, amount, type) {
  const session = await mongoose.startSession();
  try {
    return await session.withTransaction(async () => {
      // 1) L·∫•y trade
      const trade = await mongoose.connection.db.collection('trades').findOne({ tradeId });
      if (!trade) {
        throw new Error(`Trade not found: ${tradeId}`);
      }

      // N·∫øu ƒë√£ completed/failed th√¨ tr·∫£ s·ªõm
      if (trade.status === 'completed' || trade.status === 'failed') {
        return { success: true, tradeId, message: 'Trade already processed', isWin: trade.result?.isWin ?? null, profit: trade.profit ?? 0, sessionResult: trade.result?.sessionResult ?? null };
      }

      // 2) ƒê·∫∑t status processing
      await mongoose.connection.db.collection('trades').updateOne(
        { tradeId },
        { $set: { status: 'processing', updatedAt: new Date() } },
        { session }
      );

      // 3) L·∫•y session result
      const sessionDoc = await mongoose.connection.db.collection('trading_sessions').findOne(
        { sessionId },
        { result: 1 }
      );
      if (!sessionDoc || !sessionDoc.result) {
        throw new Error(`Session result not available: ${sessionId}`);
      }
      const sessionResult = sessionDoc.result;

      // 4) T√≠nh k·∫øt qu·∫£
      const userPrediction = type === 'buy' ? 'UP' : 'DOWN';
      const isWin = userPrediction === sessionResult;
      const profit = isWin ? Math.floor(amount * 0.9) : -amount;

      // 5) C·∫≠p nh·∫≠t balance
      if (isWin) {
        await mongoose.connection.db.collection('users').updateOne(
          { _id: new mongoose.Types.ObjectId(userId) },
          {
            $inc: { 'balance.frozen': -amount, 'balance.available': amount + profit },
            $set: { updatedAt: new Date() }
          },
          { session }
        );
      } else {
        await mongoose.connection.db.collection('users').updateOne(
          { _id: new mongoose.Types.ObjectId(userId) },
          {
            $inc: { 'balance.frozen': -amount },
            $set: { updatedAt: new Date() }
          },
          { session }
        );
      }

      // 6) C·∫≠p nh·∫≠t trade
      await mongoose.connection.db.collection('trades').updateOne(
        { tradeId },
        {
          $set: {
            status: 'completed',
            processedAt: new Date(),
            profit: profit,
            appliedToBalance: true,
            result: { isWin, profit, sessionResult, processedAt: new Date() }
          }
        },
        { session }
      );

      // 7) C·∫≠p nh·∫≠t th·ªëng k√™ session
      await mongoose.connection.db.collection('trading_sessions').updateOne(
        { sessionId },
        {
          $inc: {
            totalTrades: 1,
            totalWins: isWin ? 1 : 0,
            totalLosses: isWin ? 0 : 1,
            totalWinAmount: isWin ? amount : 0,
            totalLossAmount: isWin ? 0 : amount
          }
        },
        { session }
      );

      return { success: true, tradeId, isWin, profit, sessionResult };
    });
  } catch (error) {
    console.error(`‚ùå [CHECK-RESULT-DIRECT] L·ªói:`, error.message);
    return { success: false, error: error.message };
  } finally {
    await session.endSession();
  }
}

/**
 * X·ª≠ l√Ω check result (ki·ªÉm tra k·∫øt qu·∫£) v·ªõi Redis atomic operations
 */
async function processCheckResult(tradeData) {
  const { tradeId, userId, sessionId, amount, type } = tradeData;
  
  try {
    console.log(`üîç [CHECK-RESULT] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω check result: ${tradeData.tradeId}`);
    
    // Idempotency: skip if already processed
    const processedKey = `trade:${tradeId}:processed`;
    const alreadyProcessed = await redisClient.exists(processedKey);
    if (alreadyProcessed === 1) {
      console.log(`‚úÖ [CHECK-RESULT] Already processed, skipping: ${tradeId}`);
      return { success: true, message: 'Already processed' };
    }

    // S·ª≠ d·ª•ng Redis lock tr·ª±c ti·∫øp
    const lockKey = `trade:${tradeId}:processing`;
    const lockAcquired = await acquireLock(lockKey, 30000);
    
    if (!lockAcquired) {
      console.log(`‚ùå [CHECK-RESULT] Kh√¥ng th·ªÉ acquire lock cho trade ${tradeId}`);
      return {
        success: false,
        error: 'Trade is being processed by another request'
      };
    }
    
    let result;
    try {
      result = await processCheckResultDirect(tradeId, userId, sessionId, amount, type);
    } finally {
      await releaseLock(lockKey);
    }
    
    if (result && result.success) {
      // Mark idempotency flag with TTL (1h)
      await redisClient.set(processedKey, 'true', { EX: 3600 });
      // G·ª≠i Socket.IO events
      await sendSocketEvent(userId, 'trade:completed', {
        tradeId,
        sessionId,
        result: result.isWin ? 'win' : 'lose',
        profit: result.profit,
        amount: amount,
        direction: type === 'buy' ? 'UP' : 'DOWN',
        message: result.isWin ? 'üéâ Th·∫Øng!' : 'üòî Thua'
      });

      const balanceEventResult = await sendSocketEvent(userId, 'balance:updated', {
        tradeId,
        profit: result.profit,
        amount: amount,
        result: result.isWin ? 'win' : 'lose',
        message: `Balance ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t: ${result.isWin ? '+' : ''}${result.profit} VND`
      });
      
      if (!balanceEventResult) {
        console.error(`‚ùå [CHECK-RESULT] Failed to send balance:updated event for trade ${tradeId}`);
      }

      await sendSocketEvent(userId, 'trade:history:updated', {
        action: 'update',
        trade: {
          id: tradeId,
          tradeId: tradeId,
          sessionId,
          direction: type === 'buy' ? 'UP' : 'DOWN',
          amount: amount,
          status: 'completed',
          result: result.isWin ? 'win' : 'lose',
          profit: result.profit,
          createdAt: new Date().toISOString()
        },
        message: 'L·ªãch s·ª≠ giao d·ªãch ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t'
      });

      console.log(`‚úÖ [CHECK-RESULT] Check result th√†nh c√¥ng:`, {
        tradeId,
        isWin: result.isWin,
        profit: result.profit,
        sessionResult: result.sessionResult
      });
    } else if (result) {
      console.log(`‚ùå [CHECK-RESULT] Check result th·∫•t b·∫°i: ${result.error}`);
      
      // C·∫≠p nh·∫≠t trade status th√†nh failed
      try {
        await mongoose.connection.db.collection('trades').updateOne(
          { tradeId: tradeData.tradeId },
          {
            $set: {
              status: 'failed',
              errorMessage: result.error,
              updatedAt: new Date()
            }
          }
        );
      } catch (updateError) {
        console.error('‚ùå Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t trade status:', updateError);
      }
    }
    
    return result;
  } catch (error) {
    console.error(`‚ùå [CHECK-RESULT] L·ªói x·ª≠ l√Ω check result ${tradeData.tradeId}:`, error.message);
    
    // C·∫≠p nh·∫≠t trade status th√†nh failed
    try {
      await mongoose.connection.db.collection('trades').updateOne(
        { tradeId: tradeData.tradeId },
        {
          $set: {
            status: 'failed',
            errorMessage: error.message,
            updatedAt: new Date()
          }
        }
      );
    } catch (updateError) {
      console.error('‚ùå Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t trade status:', updateError);
    }
    
    return {
      success: false,
      error: error.message
    };
  }
}

// ‚úÖ DELETED: processTrade() function - Tr√πng l·∫∑p v·ªõi processCheckResult()
// Ch·ªâ s·ª≠ d·ª•ng processCheckResult() ƒë·ªÉ x·ª≠ l√Ω trades real-time




      










      
    });

    return result;
  } catch (error) {
    console.error(`‚ùå [TRADE] L·ªói x·ª≠ l√Ω trade ${tradeData.tradeId}:`, error.message);
    
    // C·∫≠p nh·∫≠t trade status th√†nh failed
    try {
      await mongoose.connection.db.collection('trades').updateOne(
        { tradeId: tradeData.tradeId },
        {
          $set: {
            status: 'failed',
            errorMessage: error.message,
            updatedAt: new Date()
          }
        }
      );
    } catch (updateError) {
      console.error('‚ùå Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t trade status:', updateError);
    }
    
    return {
      success: false,
      error: error.message
    };
  } finally {
    await session.endSession();
  }
}

/**
 * X·ª≠ l√Ω settlement (k·∫øt qu·∫£)
 */
async function processSettlement(settlementData) {
  const { sessionId } = settlementData;
  
  // ‚úÖ FIX: Th√™m Redis lock cho settlement ƒë·ªÉ tr√°nh race condition
  const settlementLockKey = `settlement:${sessionId}`;
  const lockAcquired = await acquireLock(settlementLockKey, 60000); // 60s timeout
  
  if (!lockAcquired) {
    console.log(`‚ùå [SETTLEMENT] Kh√¥ng th·ªÉ acquire lock cho session ${sessionId}`);
    return { success: false, error: 'Settlement is being processed by another worker' };
  }
  
  const session = await mongoose.startSession();
  
  try {
    console.log(`üîÑ [SETTLEMENT] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω settlement: ${settlementData.id}`);
    
    const result = await session.withTransaction(async () => {

      // 1. L·∫•y k·∫øt qu·∫£ c√≥ s·∫µn t·ª´ session
      const sessionDoc = await mongoose.connection.db.collection('trading_sessions').findOne(
        { sessionId },
        { result: 1 }
      );
      
      if (!sessionDoc || !sessionDoc.result) {
        throw new Error('Session not found or no result available');
      }
      
      const sessionResult = sessionDoc.result;
      console.log(`üìä [SETTLEMENT] S·ª≠ d·ª•ng k·∫øt qu·∫£ c√≥ s·∫µn: ${sessionResult} cho session ${sessionId}`);

      // 2. C·∫≠p nh·∫≠t session status
      const sessionUpdateResult = await mongoose.connection.db.collection('trading_sessions').updateOne(
        { sessionId },
        {
          $set: {
            status: 'COMPLETED',
            actualResult: sessionResult,
            processingComplete: true,
            updatedAt: new Date()
          }
        }
      );

      if (sessionUpdateResult.modifiedCount === 0) {
        throw new Error('Session not found or already completed');
      }

      // 2. L·∫•y t·∫•t c·∫£ trades completed trong session ch∆∞a ƒë∆∞·ª£c g·ª≠i events
      const completedTrades = await mongoose.connection.db.collection('trades').find({ 
        sessionId, 
        status: 'completed',
        appliedToBalance: true,
        eventsSent: { $ne: true } // Ch∆∞a g·ª≠i events
      }).toArray();

      console.log(`üìä [SETTLEMENT] T√¨m th·∫•y ${completedTrades.length} trades c·∫ßn g·ª≠i events`);

      let totalWins = 0;
      let totalLosses = 0;
      let totalWinAmount = 0;
      let totalLossAmount = 0;

             // 3. G·ª≠i events cho t·ª´ng trade ƒë√£ completed
       for (const trade of completedTrades) {
         // ‚úÖ Ch·ªâ g·ª≠i events, kh√¥ng x·ª≠ l√Ω trades (ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω real-time)
         const isWin = trade.result === 'win';
         const profit = trade.profit || 0;

         // C·∫≠p nh·∫≠t th·ªëng k√™
         if (isWin) {
           totalWins++;
           totalWinAmount += trade.amount;
         } else {
           totalLosses++;
           totalLossAmount += trade.amount;
         }

         console.log(`‚úÖ [SETTLEMENT] G·ª≠i events cho trade ${trade._id}: ${isWin ? 'WIN' : 'LOSE'} ${trade.amount}`);
      }

      // 4. C·∫≠p nh·∫≠t session statistics v√† ƒë√°nh d·∫•u ho√†n th√†nh
      await mongoose.connection.db.collection('trading_sessions').updateOne(
        { sessionId },
        {
          $set: {
            totalTrades: completedTrades.length,
            totalWins: totalWins,
            totalLosses: totalLosses,
            totalWinAmount: totalWinAmount,
            totalLossAmount: totalLossAmount,
            processingComplete: true,
            processingCompletedAt: new Date(),
            updatedAt: new Date()
          }
        }
      );

      console.log(`‚úÖ [SETTLEMENT] X·ª≠ l√Ω settlement th√†nh c√¥ng: ${settlementData.id}`);
      console.log(`üìä [SETTLEMENT] Th·ªëng k√™: ${completedTrades.length} trades, ${totalWins} wins, ${totalLosses} losses`);

        // ‚úÖ G·ª≠i events cho trades ƒë√£ completed
        const userTrades = new Map();
        
        // Group trades by user
        for (const trade of completedTrades) {
          const userId = trade.userId.toString();
          if (!userTrades.has(userId)) {
            userTrades.set(userId, []);
          }
          
          userTrades.get(userId).push({
            tradeId: trade.tradeId || trade._id.toString(),
            sessionId,
            result: trade.result,
            profit: trade.profit,
            amount: trade.amount,
            direction: trade.direction,
            status: 'completed',
            createdAt: trade.createdAt
          });
        }
        
        // Send batch events to each user
        for (const [userId, trades] of userTrades) {
          await sendSocketEvent(userId, 'trades:batch:completed', {
            sessionId,
            trades: trades,
            totalTrades: trades.length,
            totalWins: trades.filter(t => t.result === 'win').length,
            totalLosses: trades.filter(t => t.result === 'lose').length,
            message: `ƒê√£ x·ª≠ l√Ω ${trades.length} trades cho session ${sessionId}`
          });
          
          // ‚úÖ G·ª≠i balance:updated v·ªõi snapshot s·ªë d∆∞ m·ªõi nh·∫•t t·ª´ DB sau khi x·ª≠ l√Ω batch
          const userDoc = await mongoose.connection.db.collection('users').findOne(
            { _id: new mongoose.Types.ObjectId(userId) },
            { projection: { balance: 1 } }
          );

          await sendSocketEvent(userId, 'balance:updated', {
            userId,
            sessionId,
            tradeCount: trades.length,
            message: `Balance ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t sau settlement (${trades.length} trades)`,
            balance: {
              available: userDoc?.balance?.available ?? null,
              frozen: userDoc?.balance?.frozen ?? null
            }
          });
          
          // ‚úÖ FIX: G·ª≠i trade:history:updated cho t·ª´ng trade
          for (const trade of trades) {
            await sendSocketEvent(userId, 'trade:history:updated', {
              action: 'update',
              trade: {
                id: trade.tradeId,
                tradeId: trade.tradeId,
                sessionId: trade.sessionId,
                direction: trade.direction,
                amount: trade.amount,
                status: trade.status,
                result: trade.result,
                profit: trade.profit,
                createdAt: trade.createdAt
              }
            });
          }
        }

        // ‚úÖ ƒê√°nh d·∫•u trades ƒë√£ g·ª≠i events
        if (completedTrades.length > 0) {
          await mongoose.connection.db.collection('trades').updateMany(
            { 
              _id: { $in: completedTrades.map(t => t._id) }
            },
            { 
              $set: { eventsSent: true }
            }
          );
        }

        // ‚úÖ ALWAYS: Broadcast settlement completed to all users (k·ªÉ c·∫£ khi 0 trades)
        await sendSocketEvent('all', 'session:settlement:completed', {
          sessionId,
          result: sessionResult,
          totals: {
            totalTrades: completedTrades.length,
            totalWins,
            totalLosses,
            totalWinAmount,
            totalLossAmount
          },
          settledAt: new Date().toISOString()
        });
        
        return {
          success: true,
          sessionId,
          result: sessionResult,
          totalTrades: pendingTrades.length,
          totalWins,
          totalLosses,
          totalWinAmount,
          totalLossAmount
        };
    });

    return result;
  } catch (error) {
    console.error(`‚ùå [SETTLEMENT] L·ªói x·ª≠ l√Ω settlement ${settlementData.id}:`, error.message);
    return {
      success: false,
      error: error.message
    };
  } finally {
    await session.endSession();
    // ‚úÖ FIX: Release settlement lock
    await releaseLock(settlementLockKey);
  }
}

// ‚úÖ FIX: Sequence counter ƒë·ªÉ tr√°nh race condition
let sequenceCounter = 0;

// ‚úÖ T·ªëi ∆∞u: Event batching ƒë·ªÉ gi·∫£m s·ªë l∆∞·ª£ng requests cho VPS
const eventBatch = new Map();
const BATCH_DELAY = 100; // 100ms delay ƒë·ªÉ batch events cho VPS
const MAX_BATCH_SIZE = 10; // Max events per batch

/**
 * G·ª≠i Socket.IO event v·ªõi batching
 */
async function sendSocketEvent(userId, event, data) {
  try {
    const sequence = ++sequenceCounter;
    const eventKey = `${userId}:${event}`;
    
    // ‚úÖ BATCH: Th√™m event v√†o batch thay v√¨ g·ª≠i ngay
    if (!eventBatch.has(eventKey)) {
      eventBatch.set(eventKey, {
        userId,
        event,
        events: [],
        timeout: null
      });
    }
    
    const batch = eventBatch.get(eventKey);
    batch.events.push({
      ...data,
      sequence,
      timestamp: new Date().toISOString()
    });
    
    // ‚úÖ Clear timeout c≈© v√† set timeout m·ªõi
    if (batch.timeout) {
      clearTimeout(batch.timeout);
    }
    
    // ‚úÖ Force flush n·∫øu batch qu√° l·ªõn
    if (batch.events.length >= MAX_BATCH_SIZE) {
      if (batch.timeout) {
        clearTimeout(batch.timeout);
      }
      await flushEventBatch(eventKey);
    } else {
      batch.timeout = setTimeout(async () => {
        await flushEventBatch(eventKey);
      }, BATCH_DELAY);
    }
    
    return true;
  } catch (error) {
    console.error(`‚ùå [SOCKET] Error queuing event ${event}:`, error);
    return false;
  }
}

/**
 * Flush event batch
 */
async function flushEventBatch(eventKey) {
  try {
    const batch = eventBatch.get(eventKey);
    if (!batch || batch.events.length === 0) return;
    
    // ‚úÖ G·ª≠i batch events trong 1 request
    const response = await fetch(`${SOCKET_SERVER_URL}/emit`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        userId: batch.userId,
        event: batch.event,
        data: {
          batch: true,
          events: batch.events,
          count: batch.events.length
        }
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    
    // ‚úÖ Log batch events
    console.log(`üì° [SOCKET] Batch sent: ${batch.event} to user ${batch.userId} (${batch.events.length} events)`, result);
    
    // ‚úÖ Clear batch
    eventBatch.delete(eventKey);
    
    return result.success;
  } catch (error) {
    console.error(`‚ùå [SOCKET] Error flushing batch ${eventKey}:`, error);
    return false;
  }
}

/**
 * Kh·ªüi ƒë·ªông worker
 */
async function startWorker() {
  try {
    const workerId = process.env.WORKER_ID || '1';
    const workerNumber = process.env.WORKER_NUMBER || '1';
    console.log(`üöÄ Kh·ªüi ƒë·ªông Trade Worker ${workerNumber} (ID: ${workerId})...`);
    
    // K·∫øt n·ªëi databases
    await connectMongoDB();
    await connectRedis();
    await connectRabbitMQ();
    
    // ‚úÖ TƒÇNG PREFETCH CHO MULTIPLE WORKERS
    const prefetchCount = parseInt(process.env.WORKER_PREFETCH || '10');
    await channel.prefetch(prefetchCount);
    console.log(`üìä Worker ${workerId} prefetch set to: ${prefetchCount}`);
    
    console.log(`‚úÖ Worker ${workerNumber} ƒë√£ s·∫µn s√†ng x·ª≠ l√Ω messages (PID: ${process.pid})`);
    
    // Consumer cho trade-processing queue
    channel.consume(TRADE_PROCESSING_QUEUE, async (msg) => {
      if (!msg) return;
      
      try {
        const tradeData = JSON.parse(msg.content.toString());
        console.log(`üì• [TRADE] Nh·∫≠n trade message:`, {
          tradeId: tradeData.tradeId,
          userId: tradeData.userId,
          sessionId: tradeData.sessionId,
          amount: tradeData.amount,
          type: tradeData.type,
          action: tradeData.action
        });
        
                 // Ki·ªÉm tra action
         if (tradeData.action === 'place-trade') {
           console.log(`üìù [TRADE] X·ª≠ l√Ω place-trade cho trade: ${tradeData.tradeId}`);
           const result = await processPlaceTrade(tradeData);
           
           if (result.success) {
             console.log(`‚úÖ [TRADE] Place-trade th√†nh c√¥ng:`, {
               tradeId: result.tradeId,
               balance: result.balance
             });
           } else {
             console.error(`‚ùå [TRADE] Place-trade th·∫•t b·∫°i: ${tradeData.tradeId} - ${result.error}`);
           }
         } else if (tradeData.action === 'check-result') {
           console.log(`üîç [TRADE] X·ª≠ l√Ω check-result cho trade: ${tradeData.tradeId}`);
           const result = await processCheckResult(tradeData);
           
           if (result.success) {
             console.log(`‚úÖ [TRADE] Check-result th√†nh c√¥ng:`, {
               tradeId: result.tradeId,
               isWin: result.isWin,
               profit: result.profit
             });
           } else {
             console.error(`‚ùå [TRADE] Check-result th·∫•t b·∫°i: ${tradeData.tradeId} - ${result.error}`);
           }
         } else {
           console.error(`‚ùå [TRADE] Action kh√¥ng h·ª£p l·ªá: ${tradeData.action}`);
         }
        
        channel.ack(msg);
        console.log(`‚úÖ [TRADE] ƒê√£ acknowledge message: ${tradeData.tradeId}`);
      } catch (error) {
        console.error(`‚ùå [TRADE] L·ªói x·ª≠ l√Ω message:`, error);
        channel.ack(msg); // Acknowledge ƒë·ªÉ tr√°nh loop
      }
    });
    
    // Consumer cho settlements
    channel.consume(SETTLEMENTS_QUEUE, async (msg) => {
      if (!msg) return;
      
      try {
        const settlementData = JSON.parse(msg.content.toString());
        console.log(`üì• [SETTLEMENTS] Nh·∫≠n settlement message:`, {
          id: settlementData.id,
          sessionId: settlementData.sessionId,
          result: settlementData.result,
          timestamp: settlementData.timestamp
        });
        
        console.log(`üîÑ [SETTLEMENTS] B·∫Øt ƒë·∫ßu x·ª≠ l√Ω settlement: ${settlementData.sessionId}`);
        
        const result = await processSettlement(settlementData);
        
        if (result.success) {
          console.log(`‚úÖ [SETTLEMENTS] X·ª≠ l√Ω settlement th√†nh c√¥ng:`, {
            sessionId: result.sessionId,
            result: result.result,
            totalTrades: result.totalTrades,
            totalWins: result.totalWins,
            totalLosses: result.totalLosses
          });
        } else {
          console.error(`‚ùå [SETTLEMENTS] X·ª≠ l√Ω settlement th·∫•t b·∫°i: ${settlementData.id} - ${result.error}`);
        }
        
        channel.ack(msg);
        console.log(`‚úÖ [SETTLEMENTS] ƒê√£ acknowledge message: ${settlementData.id}`);
      } catch (error) {
        console.error(`‚ùå [SETTLEMENTS] L·ªói x·ª≠ l√Ω message:`, error);
        channel.ack(msg); // Acknowledge ƒë·ªÉ tr√°nh loop
      }
    });
    
    console.log(`üéâ Worker ${workerId} ƒë√£ kh·ªüi ƒë·ªông th√†nh c√¥ng!`);
    console.log('üìã ƒêang l·∫Øng nghe:');
    console.log(`   - Trade processing queue: ${TRADE_PROCESSING_QUEUE}`);
    console.log(`   - Settlements queue: ${SETTLEMENTS_QUEUE}`);
    
  } catch (error) {
    console.error('‚ùå L·ªói kh·ªüi ƒë·ªông worker:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('\nüõë ƒêang t·∫Øt worker...');
  
  if (channel) {
    await channel.close();
  }
  
  if (connection) {
    await connection.close();
  }
  
  if (redisClient) {
    await redisClient.disconnect();
  }
  
  console.log('‚úÖ Worker ƒë√£ t·∫Øt');
  process.exit(0);
});

// ‚úÖ GRACEFUL SHUTDOWN HANDLERS
let isShuttingDown = false;

async function gracefulShutdown(signal) {
  if (isShuttingDown) {
    console.log('‚ö†Ô∏è Shutdown already in progress...');
    return;
  }
  
  isShuttingDown = true;
  const workerNumber = process.env.WORKER_NUMBER || '1';
  console.log(`\nüõë Worker ${workerNumber} nh·∫≠n signal ${signal}, ƒëang t·∫Øt gracefully...`);
  
  try {
    // Close RabbitMQ connections
    if (channel) {
      console.log('üîÑ ƒêang ƒë√≥ng RabbitMQ channel...');
      await channel.close();
    }
    
    if (connection) {
      console.log('üîÑ ƒêang ƒë√≥ng RabbitMQ connection...');
      await connection.close();
    }
    
    // Close Redis connection
    if (redisClient) {
      console.log('üîÑ ƒêang ƒë√≥ng Redis connection...');
      await redisClient.disconnect();
    }
    
    // Close MongoDB connection
    if (mongoose.connection.readyState === 1) {
      console.log('üîÑ ƒêang ƒë√≥ng MongoDB connection...');
      await mongoose.connection.close();
    }
    
    console.log('‚úÖ Worker ƒë√£ t·∫Øt gracefully');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå L·ªói trong qu√° tr√¨nh shutdown:', error);
    process.exit(1);
  }
}

// ‚úÖ SIGNAL HANDLERS
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGQUIT', () => gracefulShutdown('SIGQUIT'));

// ‚úÖ UNCAUGHT EXCEPTION HANDLERS
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
  gracefulShutdown('uncaughtException');
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
  gracefulShutdown('unhandledRejection');
});

// ‚úÖ HEALTH CHECK
setInterval(() => {
  if (!isShuttingDown) {
    const workerNumber = process.env.WORKER_NUMBER || '1';
    console.log(`üíì Worker ${workerNumber} health check - PID: ${process.pid}, Uptime: ${Math.floor(process.uptime())}s`);
  }
}, 60000); // M·ªói 1 ph√∫t

// Start worker
startWorker();
